---
title: "California Bee Diversity & Conservation Gaps"
author: "Gretchen LeBuhn"
date: "`r Sys.Date()`"
format:
  html:
    self-contained: true
    toc: true
    toc-depth: 4
    theme: sandstone
    code-fold: true
    fig-width: 12
    fig-height: 8
execute:
  warning: false
  message: false
---

## Overview

This document overlays California bee species richness and endemism (CWE) data with the CA Nature Terrestrial 30x30 Conserved Areas layer to identify **conservation gaps** — areas of high bee diversity or endemism that fall outside GAP 1 & 2 protected lands.

Four maps are produced:

1.  Bee richness overlaid on conserved lands
2.  Bee endemism (CWE) overlaid on conserved lands
3.  Conservation gaps — high richness, low protection
4.  Conservation gaps — high endemism, low protection

------------------------------------------------------------------------

## Setup

```{r setup}
# Load googledrive to authenticate and access files stored on Google Drive
# This package handles OAuth tokens and Drive API calls
library(googledrive)

# Load readr for fast, clean reading of CSV files into R
# It handles column type guessing and encoding better than base read.csv()
library(readr)

# Load dplyr for data manipulation verbs like filter(), mutate(), and select()
# It provides a consistent grammar for transforming data frames
library(dplyr)

# Load tidyverse as a meta-package covering ggplot2, tidyr, stringr, and more
# Many of its member packages are used throughout this script
library(tidyverse)

# Load sf (simple features) for reading, transforming, and joining spatial data
# It represents geographic features as standard R data frames with a geometry column
library(sf)

# Load ggplot2 for building publication-quality maps and figures layer by layer
# It is already included in tidyverse but loaded explicitly for clarity
library(ggplot2)

# Load viridis for perceptually uniform, colorblind-friendly color palettes
# These palettes work well for continuous variables like richness and CWE
library(viridis)

# Load patchwork to combine multiple ggplot objects into a single figure layout
# Useful for side-by-side or stacked multi-panel map displays
library(patchwork)

# Load scales for formatting axis labels and legend text (e.g., commas, percentages)
# Used here to format richness and CWE values on map legends
library(scales)

# Load glue
library(glue)

# Load tigris for the Census Bureau CA state boundary (used in map outlines)
# Falls back gracefully to a convex hull if tigris is not installed
library(tigris)

# Set gargle options to cache the OAuth token in a local .secrets folder
# This means you only need to authenticate in the browser once per machine
options(gargle_oauth_cache = ".secrets", gargle_oauth_email = NA_character_)

# Authenticate with Google Drive using the cached token in .secrets
# If no cached token exists, this will open a browser window for sign-in
drive_auth(cache = ".secrets")
```

------------------------------------------------------------------------

## Load Data

### Bee diversity data (from Google Drive)

This loads the processed bee data that already has ecoregion assignments and spatial coordinates in CA Albers (CRS 3310).

```{r load-bee-data}


# List files in the github_data/bees_climate_data/processed folder on Google Drive and filter to the GeoPackage
# drive_ls() returns a tibble of file metadata; filter() finds the exact filename
bee_items <- drive_ls(path = "github_data/bees_climate_data/processed") |>
  filter(name == "eco.data.gpkg")

# Check whether the GeoPackage was found (nrow == 1 means exactly one match)
# If found, download it to a temporary file and read it as a spatial object
if (nrow(bee_items) == 1) {

  # Create a temporary file path with a .gpkg extension to store the download
  # tempfile() generates a unique path in the system temp directory
  gpkg_path <- tempfile(fileext = ".gpkg")

  # Download the GeoPackage from Drive to the local temp path
  # overwrite = TRUE replaces any existing file at that temp path
  drive_download(bee_items, path = gpkg_path, overwrite = TRUE)

  # Read the GeoPackage into R as an sf object preserving geometry and CRS
  # quiet = TRUE suppresses the layer info message printed by st_read()
  bee.data <- st_read(gpkg_path, quiet = TRUE)

  # Print a confirmation message so you know which loading path was used
  # This helps with debugging if results look unexpected
  message("Loaded bee data from GeoPackage.")

} else {

  # If no GeoPackage was found, fall back to loading from the CSV file
  # This branch re-applies the column renaming from the original processing script
  message("GeoPackage not found — loading from CSV.")

  # List files in github_data/bees_climate_data/processed and filter to the CSV filename
  # Same pattern as above but targeting eco.data.csv instead
  csv_items <- drive_ls(path = "github_data/bees_climate_data/processed") |>
    filter(name == "eco.data.csv")

  # Halt execution with an informative error if the CSV is also missing
  # This prevents silent failures where bee.data would be undefined
  stopifnot("eco.data.csv not found in github_data/bees_climate_data/processed" = nrow(csv_items) == 1)

  # Create a temporary file path for the CSV download
  # The .csv extension ensures readr treats it correctly
  csv_path <- tempfile(fileext = ".csv")

  # Download the CSV from Drive to the local temp path
  # overwrite = TRUE ensures a fresh copy even if the file already exists
  drive_download(csv_items, path = csv_path, overwrite = TRUE)

  # Read the CSV and apply the full processing pipeline in one chained expression:
  # rename() restores human-readable column names from the raw encoded field names,
  # select() keeps only the columns needed for spatial analysis and modeling,
  # drop_na() removes rows with missing coordinate values that cannot be mapped,
  # and st_as_sf() converts the flat data frame into a spatial sf object using CRS 3310
  bee.data <- read_csv(csv_path, show_col_types = FALSE) |>
    rename(x.axis = X_Axis_0_, y.axis = X_Axis_1_,
           cwe = X_ENDC_CWE_, richness = X_ENDC_RICHNESS_) |>
    select(x.axis, y.axis, cwe, richness,
           starts_with("bio"), starts_with("L")) |>
    drop_na(x.axis, y.axis) |>
    st_as_sf(coords = c("x.axis", "y.axis"), crs = 3310)
}

# Reproject bee.data to CA Albers (EPSG 3310) to match the conserved areas layer
# st_transform() reprojects any sf object to the target CRS in meters
bee.data <- st_transform(bee.data, crs = 3310)

# Print a summary message showing grid cell count and the range of both response variables
# glue::glue() lets us embed R expressions directly inside the string using {}
message(glue::glue(
  "Bee data: {nrow(bee.data)} grid cells | ",
  "Richness range: {round(min(bee.data$richness, na.rm=TRUE), 1)} – ",
  "{round(max(bee.data$richness, na.rm=TRUE), 1)} | ",
  "CWE range: {round(min(bee.data$cwe, na.rm=TRUE), 3)} – ",
  "{round(max(bee.data$cwe, na.rm=TRUE), 3)}"
))
```

### 30x30 Conserved Areas shapefile (from Google Drive)

The zip file is downloaded from Google Drive and unzipped automatically. Update `conserved_zip_name` and `conserved_drive_path` if your file or folder name differs.

```{r load-conserved}


# Set the Google Drive folder path where the conserved areas zip file is stored
# This points to the github_data/bees_climate_data folder where the zip was uploaded
conserved_drive_path <- "github_data/bees_climate_data"

# Set the expected filename of the zip on Google Drive (URL-encoded with %2C for comma)
# Update this if the file was saved with a different name on Drive
conserved_zip_name   <- "30x30_Conserved_Areas%2C_Terrestrial_(2025).zip"

# List files in the Drive folder and filter to the URL-encoded zip filename
# drive_ls() returns all files in the folder; filter() isolates the target
conserved_item <- drive_ls(path = conserved_drive_path) |>
  filter(name == conserved_zip_name)

# If the URL-encoded name returned no matches, try the literal comma version as a fallback
# Some systems or upload tools store the filename with a literal comma instead of %2C
if (nrow(conserved_item) == 0) {

  # Repeat the Drive listing and filter for the comma version of the filename
  # This handles both naming conventions without requiring manual intervention
  conserved_item <- drive_ls(path = conserved_drive_path) |>
    filter(name == "30x30_Conserved_Areas, Terrestrial_(2025).zip")
}

# Stop execution with a descriptive error message if neither filename was found
# This prevents the script from proceeding without the required spatial data
stopifnot(
  "Conserved areas zip not found on Google Drive — check conserved_drive_path and conserved_zip_name" =
    nrow(conserved_item) == 1
)

# Create a temporary file path with a .zip extension to receive the download
# tempfile() guarantees a unique path that won't conflict with other files
zip_path <- tempfile(fileext = ".zip")

# Download the zip file from Drive to the local temporary path
# overwrite = TRUE ensures any previous temp file at that path is replaced
drive_download(conserved_item, path = zip_path, overwrite = TRUE)

# Print a confirmation that the download completed successfully
# This helps track progress since the conserved areas file can be large
message("Downloaded conserved areas zip.")

# Create a temporary directory to extract the zip contents into
# tempfile() here generates a unique folder name prefixed with "conserved_"
conserved_dir <- tempfile("conserved_")

# Create the directory on disk so unzip() has somewhere to write files
# dir.create() will error if the path already exists, but tempfile() ensures uniqueness
dir.create(conserved_dir)

# Extract all files from the zip archive into the temporary directory
# exdir sets the destination; unzip() preserves any subfolder structure inside the zip
unzip(zip_path, exdir = conserved_dir)

# Search recursively through the extracted directory for any file ending in .shp
# recursive = TRUE handles cases where the shapefile is inside a nested subfolder
conserved_path <- list.files(
  conserved_dir,
  pattern     = "\\.shp$",
  full.names  = TRUE,
  recursive   = TRUE,
  ignore.case = TRUE
)

# Stop execution if no .shp file was found after unzipping
# This catches corrupt zips or zips that contain only non-shapefile formats
stopifnot(
  "No .shp file found after unzipping — check the zip contents" =
    length(conserved_path) >= 1
)

# Take only the first .shp path in case multiple shapefiles exist in the zip
# In practice the 30x30 zip contains one shapefile, but this makes the code robust
conserved_path <- conserved_path[1]

# Print the path of the shapefile being read so you can verify it is correct
# This is especially helpful if the zip contains a nested folder structure
message("Reading shapefile from: ", conserved_path)

# Read the shapefile into R as an sf object and immediately reproject to CA Albers
# quiet = TRUE suppresses the default layer info message from st_read()
conserved <- st_read(conserved_path, quiet = TRUE) |>
  st_transform(crs = 3310)

# Print the number of polygons loaded as a basic sanity check
# The 30x30 layer contains tens of thousands of polygons statewide
message(glue::glue("Conserved areas: {nrow(conserved)} polygons loaded."))
```

------------------------------------------------------------------------

## Prepare Conserved Areas

GAP 1 = permanently protected, biodiversity focus\
GAP 2 = managed mostly for biodiversity but may allow some extractive use\
GAP 3 = multiple use, biodiversity not primary focus\
GAP 4 = no known biodiversity focus (e.g. working lands)

We define **"well conserved"** as GAP 1 or GAP 2.

```{r prep-conserved}
# Filter polygons that contain any GAP 1 or GAP 2 acreage
conserved_gap12 <- conserved |>
  filter(Gap1_acres > 0 | Gap2_acres > 0)

message(glue("Invalid geometries before repair: {sum(!st_is_valid(conserved_gap12))}"))

# Repair geometries (drop Z first can help; safe to do either way)
conserved_gap12 <- conserved_gap12 |>
  mutate(geometry = st_zm(geometry, drop = TRUE, what = "ZM")) |>
  mutate(geometry = st_make_valid(geometry))

message(glue("Invalid geometries after repair:  {sum(!st_is_valid(conserved_gap12))}"))

message("Dissolving GAP 1 & 2 areas... (may take a moment)")

# Dissolve into one geometry
conserved_union <- conserved_gap12 |>
  summarise(geometry = st_union(geometry)) |>
  mutate(protected = "GAP 1 & 2")

# Report total GAP 1 + 2 acres
gap12_acres <- sum(conserved_gap12$Gap1_acres + conserved_gap12$Gap2_acres, na.rm = TRUE)

message(glue(
  "GAP 1 & 2 coverage: {round(gap12_acres / 1e6, 2)} million acres"
))
```

------------------------------------------------------------------------

## Classify Bee Grid Cells by Protection Status

Each bee grid cell is classified as **protected** (intersects GAP 1 or 2) or **unprotected**.

```{r classify-protection}
# Perform a spatial join to identify which bee grid cells overlap GAP 1 & 2 areas
# st_intersects returns a match wherever a bee cell touches the conserved union polygon;
# cells that don't overlap receive NA in the "protected" column
bee_prot <- st_join(
  bee.data,
  conserved_union |> select(protected),
  join = st_intersects
) |>
  # Create a logical TRUE/FALSE column: TRUE if the cell fell inside a protected area
  # !is.na(protected) is TRUE for cells that matched and FALSE for those that did not
  mutate(is_protected = !is.na(protected))

# Build a summary table counting protected vs unprotected cells
# st_drop_geometry() removes the spatial column so count() works on a plain data frame
prot_summary <- bee_prot |>
  st_drop_geometry() |>
  # Count how many cells fall into each category (TRUE = protected, FALSE = unprotected)
  # mutate() then adds a percentage column rounded to one decimal place
  count(is_protected) |>
  mutate(pct = round(100 * n / sum(n), 1))

# Print the protection summary table to the console for a quick sanity check
# This shows how many grid cells are inside vs outside conserved lands
print(prot_summary)
```

------------------------------------------------------------------------

## Define Conservation Gap Thresholds

"High" richness and endemism are defined as cells in the **top 25th percentile** (i.e., ≥ 75th percentile). Adjust `gap_quantile` below to change this threshold.

```{r gap-thresholds}
# Set the quantile threshold that defines "high" biodiversity (0.75 = top 25%)
# Increase this value (e.g., 0.90) to identify only the very highest-priority cells
gap_quantile <- 0.75

# Calculate the richness value at the chosen quantile across all bee grid cells
# na.rm = TRUE ensures missing values don't cause quantile() to return NA
rich_thresh <- quantile(bee.data$richness, gap_quantile, na.rm = TRUE)

# Calculate the CWE value at the chosen quantile across all bee grid cells
# This threshold is applied symmetrically with rich_thresh to define "high endemism"
cwe_thresh  <- quantile(bee.data$cwe, gap_quantile, na.rm = TRUE)

# Print both thresholds so the exact cutoff values are visible in the output
# This makes the gap definition transparent and reproducible in any write-up
message(glue::glue(
  "Richness threshold (≥{gap_quantile*100}th pctile): {round(rich_thresh, 1)} species\n",
  "CWE threshold     (≥{gap_quantile*100}th pctile): {round(cwe_thresh, 4)}"
))

# Add four new columns to bee_prot classifying each cell's gap and priority status:
# rich_gap and cwe_gap are TRUE/FALSE flags for cells that are both high-diversity
# AND unprotected — these are the conservation gaps we want to map
bee_gaps <- bee_prot |>
  mutate(
    # TRUE if the cell has high richness AND falls outside GAP 1 & 2 protection
    # Both conditions must be met simultaneously: above threshold AND not protected
    rich_gap = richness >= rich_thresh & !is_protected,

    # TRUE if the cell has high CWE AND falls outside GAP 1 & 2 protection
    # Same logic as rich_gap but applied to the endemism variable
    cwe_gap  = cwe >= cwe_thresh & !is_protected,

    # Assign each cell to one of four richness-by-protection categories for map coloring
    # case_when() evaluates conditions top-to-bottom and assigns the first match
    rich_priority = case_when(
      richness >= rich_thresh & !is_protected ~ "High richness, unprotected",
      richness >= rich_thresh &  is_protected ~ "High richness, protected",
      richness <  rich_thresh & !is_protected ~ "Lower richness, unprotected",
      # TRUE acts as the else clause and catches all remaining cells
      TRUE                                    ~ "Lower richness, protected"
    ),

    # Assign each cell to one of four endemism-by-protection categories for map coloring
    # Mirrors the rich_priority logic but uses cwe and cwe_thresh instead
    cwe_priority = case_when(
      cwe >= cwe_thresh & !is_protected ~ "High endemism, unprotected",
      cwe >= cwe_thresh &  is_protected ~ "High endemism, protected",
      cwe <  cwe_thresh & !is_protected ~ "Lower endemism, unprotected",
      # The TRUE fallback captures low-endemism, protected cells
      TRUE                              ~ "Lower endemism, protected"
    )
  )
```

------------------------------------------------------------------------

## Maps

### Shared map elements

```{r map-theme}
# ── Presentation colour palette ───────────────────────────────────────────────
# Dark slide background and white text make maps pop in a darkened room
bg_col      <- "#0d1117"   # near-black background matching dark slide decks
text_col    <- "#ffffff"   # white for all text and legend labels
subtitle_col <- "#b0b8c8"  # muted blue-gray for subtitles — readable but not competing

# ── Presentation-optimised ggplot theme ───────────────────────────────────────
# Large base_size (16) ensures text is legible from the back of a conference room
map_theme <- theme_void(base_size = 16) +
  theme(
    # Dark panel background so the map fills the slide without a white box
    # plot.background covers the entire figure area including margins
    plot.background  = element_rect(fill = bg_col,  color = NA),
    panel.background = element_rect(fill = bg_col,  color = NA),

    # Bold white title, large enough to read at the back of a room
    # margin adds breathing room below the title
    plot.title    = element_text(color = text_col,    face = "bold",
                                 size = 20, margin = margin(b = 6)),

    # Muted subtitle in a lighter gray so it reads but doesn't compete with the title
    plot.subtitle = element_text(color = subtitle_col, size = 13,
                                 margin = margin(b = 10)),

    # Legend at the bottom keeps the full map height available for the state shape
    # White legend text and background-matching fill keep it on-brand
    legend.position    = "bottom",
    legend.direction   = "horizontal",
    legend.title       = element_text(color = text_col, size = 13, face = "bold"),
    legend.text        = element_text(color = text_col, size = 11),
    legend.background  = element_rect(fill = bg_col, color = NA),
    legend.key         = element_rect(fill = bg_col, color = NA),
    legend.key.width   = unit(1.8, "cm"),   # wider colour bar for continuous legends
    legend.key.height  = unit(0.4, "cm"),

    # Generous margins prevent the map being clipped or feeling cramped on a slide
    plot.margin = margin(12, 16, 12, 16)
  )

# ── California state outline ──────────────────────────────────────────────────
# A crisp white border anchors the map geographically and reads well on dark backgrounds
# Uses tigris if available; falls back to the convex hull of conserved areas otherwise
ca_outline_layer <- tryCatch({
  # tigris::states() returns Census Bureau state boundary shapefiles
  # cb = TRUE uses the generalised (smaller file) cartographic boundary
  ca_state <- tigris::states(cb = TRUE, progress_bar = FALSE) |>
    dplyr::filter(STUSPS == "CA") |>
    sf::st_transform(crs = 3310)
  # Return a white outline with no fill — just the boundary as a reference frame
  # linewidth = 0.6 is visible but doesn't overpower the data layers
  list(
    geom_sf(data = ca_state, fill = NA, color = "white", linewidth = 0.6),
    coord_sf(expand = FALSE)
  )
}, error = function(e) {
  # If tigris is not installed, fall back to the convex hull of conserved areas
  # This is rougher but avoids a hard dependency on tigris
  ca_hull <- sf::st_union(conserved |> sf::st_make_valid()) |> sf::st_convex_hull()
  list(
    geom_sf(data = ca_hull, fill = NA, color = "white", linewidth = 0.6),
    coord_sf(expand = FALSE)
  )
})

# ── Conserved lands base layer ────────────────────────────────────────────────
# A slightly warm gray-green fill distinguishes protected land from the dark background
# without competing with the bee data colour scales drawn on top
conserved_base <- geom_sf(
  data  = conserved_gap12,
  # Warm gray-green: legible on dark background, reads as "land" not "data"
  fill  = "#3a4a3a",
  # No border lines — thousands of polygon edges would create visual noise
  color = NA,
  # Semi-transparent so bee data points drawn on top are clearly visible
  alpha = 0.75
)
```

------------------------------------------------------------------------

### Map 1 — Bee Richness Overlaid on Conserved Lands

```{r map-richness-overlay, fig.alt="Bee richness across California with GAP 1 & 2 conserved areas shown in gray"}
# Initialize the map with a dark background rectangle as the first layer
# This ensures the bg_col fills any whitespace outside the spatial extent
map1 <- ggplot() +
  # Dark background fills the full plot area behind all spatial layers
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
           fill = bg_col) +
  # Conserved lands base layer (warm gray-green polygons)
  conserved_base +
  # CA state outline in white for geographic context
  ca_outline_layer +
  # Bee grid cells coloured by richness; larger points read well on a projected slide
  # size = 1.4 and alpha = 0.9 give a dense, vivid appearance without overplotting
  geom_sf(
    data  = bee.data,
    aes(color = richness),
    size  = 1.4,
    alpha = 0.9,
    shape = 16   # filled circle — cleanest shape at small sizes
  ) +
  # Turbo palette: full rainbow from blue (low) to red (high), very vivid when projected
  # guide = guide_colorbar() with horizontal orientation matches the bottom legend layout
  scale_color_viridis_c(
    option = "turbo",
    name   = "Species richness",
    labels = label_number(accuracy = 1),
    guide  = guide_colorbar(title.position = "top", title.hjust = 0.5,
                            barwidth = 15, barheight = 0.6)
  ) +
  labs(
    title    = "Bee Species Richness Across California",
    subtitle = "Gray-green = GAP 1 & 2 conserved lands  ·  Points = bee survey grid cells"
  ) +
  map_theme

map1
```

------------------------------------------------------------------------

### Map 2 — Bee Endemism (CWE) Overlaid on Conserved Lands

```{r map-cwe-overlay, fig.alt="Bee endemism (CWE) across California with GAP 1 & 2 conserved areas shown in gray"}
map2 <- ggplot() +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
           fill = bg_col) +
  conserved_base +
  ca_outline_layer +
  # CWE points: same size as map1 for visual consistency
  geom_sf(
    data  = bee.data,
    aes(color = cwe),
    size  = 1.4,
    alpha = 0.9,
    shape = 16
  ) +
  # Inferno palette: black → purple → orange → yellow; vivid and distinct from map1
  scale_color_viridis_c(
    option = "inferno",
    name   = "Bee rarity (CWE)",
    labels = label_number(accuracy = 0.001),
    guide  = guide_colorbar(title.position = "top", title.hjust = 0.5,
                            barwidth = 15, barheight = 0.6)
  ) +
  labs(
    title    = "Bee Rarity (Community-Weighted Endemism) Across California",
    subtitle = "Gray-green = GAP 1 & 2 conserved lands  ·  CWE highlights range-restricted species"
  ) +
  map_theme

map2
```

------------------------------------------------------------------------

### Map 3 — Conservation Gap: High Richness, Unprotected

```{r map-richness-gap, fig.alt="Conservation gap map showing high bee richness areas outside GAP 1 & 2 lands"}
# High-contrast palette designed for dark backgrounds and projection
# Orange on dark is far more vivid than red; teal reads distinctly from the background
gap_colors_rich <- c(
  "High richness, unprotected"   = "#FF6B2B",   # vivid orange — the key message of the map
  "High richness, protected"     = "#2ECC71",   # bright green — already conserved, reassuring
  "Lower richness, unprotected"  = "#4a4a5a",   # dark blue-gray — recedes into background
  "Lower richness, protected"    = "#2a3a2a"    # very dark green — barely visible, as intended
)

map3 <- ggplot() +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
           fill = bg_col) +
  conserved_base +
  ca_outline_layer +
  # Draw lower-priority cells first so gap cells are rendered on top
  # This prevents orange points from being hidden under gray/dark-green points
  geom_sf(
    data  = bee_gaps |> filter(!rich_gap),
    aes(color = rich_priority),
    size  = 1.2, alpha = 0.7, shape = 16
  ) +
  # Draw gap cells last so they sit on top of all other layers
  geom_sf(
    data  = bee_gaps |> filter(rich_gap),
    aes(color = rich_priority),
    size  = 1.8,   # slightly larger to make gaps stand out even more
    alpha = 1.0,
    shape = 16
  ) +
  scale_color_manual(
    values = gap_colors_rich,
    name   = NULL,
    # Override point size in the legend so all categories are clearly visible
    guide  = guide_legend(
      override.aes   = list(size = 4),
      nrow           = 2,
      title.position = "top"
    )
  ) +
  labs(
    title    = "Conservation Gap: Bee Species Richness",
    subtitle = glue::glue(
      "Orange = high richness (≥ {round(rich_thresh,1)} spp) AND outside protected lands  ·  ",
      "Threshold = {gap_quantile*100}th percentile"
    )
  ) +
  map_theme

map3
```

------------------------------------------------------------------------

### Map 4 — Conservation Gap: High Endemism, Unprotected

```{r map-cwe-gap, fig.alt="Conservation gap map showing high bee endemism areas outside GAP 1 & 2 lands"}
gap_colors_cwe <- c(
  "High endemism, unprotected"   = "#FF6B2B",   # same vivid orange as map3 for consistency
  "High endemism, protected"     = "#2ECC71",   # bright green
  "Lower endemism, unprotected"  = "#4a4a5a",   # dark blue-gray
  "Lower endemism, protected"    = "#2a3a2a"    # very dark green
)

map4 <- ggplot() +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
           fill = bg_col) +
  conserved_base +
  ca_outline_layer +
  # Render background (non-gap) cells first, gap cells on top
  geom_sf(
    data  = bee_gaps |> filter(!cwe_gap),
    aes(color = cwe_priority),
    size  = 1.2, alpha = 0.7, shape = 16
  ) +
  geom_sf(
    data  = bee_gaps |> filter(cwe_gap),
    aes(color = cwe_priority),
    size  = 1.8, alpha = 1.0, shape = 16
  ) +
  scale_color_manual(
    values = gap_colors_cwe,
    name   = NULL,
    guide  = guide_legend(
      override.aes   = list(size = 4),
      nrow           = 2,
      title.position = "top"
    )
  ) +
  labs(
    title    = "Conservation Gap: Bee Rarity (CWE)",
    subtitle = glue::glue(
      "Orange = high rarity (≥ {round(cwe_thresh,4)} CWE) AND outside protected lands  ·  ",
      "Threshold = {gap_quantile*100}th percentile"
    )
  ) +
  map_theme

map4
```

## Summary Statistics

### Richness gap

```{r summary-richness}
# Start from the gap-classified data and remove the geometry column before summarising
# st_drop_geometry() is needed because group_by() and summarise() work on plain data frames
bee_gaps |>
  st_drop_geometry() |>
  # Group rows by their four-category richness-protection label
  # This produces one summary row per category in the output table
  group_by(rich_priority) |>
  # Calculate the count, mean richness, and median richness for each category
  # na.rm = TRUE ensures missing richness values don't propagate into statistics
  summarise(
    n_cells         = n(),
    mean_richness   = round(mean(richness, na.rm = TRUE), 1),
    median_richness = round(median(richness, na.rm = TRUE), 1)
  ) |>
  # Sort rows so the highest-richness categories appear at the top of the table
  # desc() reverses the default ascending sort order
  arrange(desc(mean_richness)) |>
  # Render the result as a formatted HTML table with a descriptive caption
  # knitr::kable() is the standard table renderer for Quarto HTML output
  knitr::kable(caption = "Bee richness by conservation status")
```

### Endemism gap

```{r summary-cwe}
# Mirror the richness summary structure but grouped and summarised on endemism
# st_drop_geometry() again drops the spatial column before aggregation
bee_gaps |>
  st_drop_geometry() |>
  # Group by the four-category endemism-protection label
  group_by(cwe_priority) |>
  # Calculate count, mean CWE, and median CWE rounded to four decimal places
  # Four decimals are appropriate because CWE values are typically small fractions
  summarise(
    n_cells    = n(),
    mean_cwe   = round(mean(cwe, na.rm = TRUE), 4),
    median_cwe = round(median(cwe, na.rm = TRUE), 4)
  ) |>
  # Sort so the highest-endemism category appears first in the table
  arrange(desc(mean_cwe)) |>
  # Render as a formatted table with a caption identifying the variable
  knitr::kable(caption = "Bee endemism (CWE) by conservation status")
```

### Overlap: cells that are gaps for BOTH richness and endemism

```{r summary-overlap}
# Filter to cells where both rich_gap and cwe_gap are TRUE simultaneously
# The & operator requires both conditions to be met; these dual-gap cells are the
# highest conservation priorities — high richness AND high endemism AND unprotected
dual_gap <- bee_gaps |>
  st_drop_geometry() |>
  filter(rich_gap & cwe_gap)

# Report the count of dual-gap cells with an explanatory message
# nrow(dual_gap) dynamically inserts the count into the glue string
message(glue::glue(
  "{nrow(dual_gap)} grid cells are high in BOTH richness AND endemism ",
  "and fall outside GAP 1 & 2 protected areas — these are the highest-priority gaps."
))
```

------------------------------------------------------------------------

## Export Gap Layers

Save the classified grid as a GeoPackage for use in QGIS or ArcGIS.

```{r export}
# Define the output directory name where exported GeoPackages will be saved
# A dedicated outputs/ folder keeps exported files separate from raw data
out_dir <- "outputs"

# Create the outputs directory if it doesn't already exist
# showWarnings = FALSE suppresses the warning that fires if the folder is already present
dir.create(out_dir, showWarnings = FALSE)

# Write the full classified bee grid (all cells with gap status columns) to a GeoPackage
# append = FALSE overwrites any existing file at this path rather than adding a new layer
st_write(
  bee_gaps,
  file.path(out_dir, "bee_conservation_gaps.gpkg"),
  append = FALSE
)

# Subset to only the highest-priority cells: those flagged as a gap for richness OR endemism
# The | (OR) operator keeps a cell if it is a gap on either variable, not necessarily both
priority_gaps <- bee_gaps |>
  filter(rich_gap | cwe_gap)

# Write the priority-only subset to a separate GeoPackage for easy use in GIS software
# This smaller file loads and renders faster than the full classified grid
st_write(
  priority_gaps,
  file.path(out_dir, "bee_priority_gaps.gpkg"),
  append = FALSE
)

# Print a final confirmation message with cell counts for both exported files
# This confirms the export completed and gives a quick summary of what was saved
message(glue::glue(
  "Exported {nrow(bee_gaps)} classified cells and ",
  "{nrow(priority_gaps)} priority gap cells to {out_dir}/"
))
```

------------------------------------------------------------------------

## Notes on the 30x30 Conserved Areas Data

The Terrestrial 30x30 Conserved Areas layer (CA Nature, 2024b) integrates:

-   **CPAD** (California Protected Areas Database, GreenInfo Network)
-   **CCED** (California Conservation Easement Database, GreenInfo Network)
-   **PAD-US** (USGS, Gap Analysis Project) for GAP status coding

GAP status was assigned using an 80% areal overlap rule at the Superunit level. Areas with less than 80% overlap with any single GAP code were resolved at the Holdings level. Remaining uncoded areas were assigned GAP 4.

Layer citation: *California Protected Areas Database (CPAD). December 2024. GreenInfo Network. www.calands.org*
