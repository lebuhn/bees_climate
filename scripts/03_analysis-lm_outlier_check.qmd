---
title: "Linear Model Analysis by L1 Group"
author: "Gretchen LeBuhn"
date: today
format: 
  html:
    toc: true
    code-fold: show
    code-tools: true
    theme: cosmo
  pdf:
    toc: true
    number-sections: true
execute:
  echo: true
  warning: false
---

# Introduction

This document analyzes the relationship between bioclimatic variables and the response variable `cwe`, with separate analyses for each group in the `L1` variable. This approach allows us to see if the relationships between bioclimatic factors and our response variable differ across different L1 groups.

```{r setup}
#| label: setup
#| message: false

# Load necessary packages
library(knitr)      # For nice table formatting
library(ggplot2)    # For custom visualization
library(tidyverse)  # For data manipulation and visualization
```

# Data Preparation

First, we need to load and explore our data to understand its structure.

```{r load-data}
#| label: load-data

# Read in the data from a CSV file and change the level names
data <- read.csv("../data/working/eco.data.csv") |> 
  rename(L1 = L1.name, L2 = L2.name, L3 = L3.name)

# Create a lookup table for bioclimatic variables
bio_names <- c(
  bio1 = "Annual Mean Temperature",
  bio2 = "Mean Diurnal Range",
  bio3 = "Isothermality",
  bio4 = "Temperature Seasonality",
  bio5 = "Max Temperature of Warmest Month",
  bio6 = "Min Temperature of Coldest Month",
  bio7 = "Temperature Annual Range",
  bio8 = "Mean Temperature of Wettest Quarter",
  bio9 = "Mean Temperature of Driest Quarter",
  bio10 = "Mean Temperature of Warmest Quarter",
  bio11 = "Mean Temperature of Coldest Quarter",
  bio12 = "Annual Precipitation",
  bio13 = "Precipitation of Wettest Month",
  bio14 = "Precipitation of Driest Month",
  bio15 = "Precipitation Seasonality",
  bio16 = "Precipitation of Wettest Quarter",
  bio17 = "Precipitation of Driest Quarter",
  bio18 = "Precipitation of Warmest Quarter",
  bio19 = "Precipitation of Coldest Quarter"
)

# Check the structure of the data
str(data)

# Get a summary of the key variables
cat("Summary of response variable and bioclimatic predictors:\n\n")
summary_data <- summary(data[, c("cwe", paste0("bio", 1:19))])
print(summary_data)

# Get unique values of the L1 variable (the grouping variable)
l1_levels <- unique(data$L1)
cat("Unique L1 levels:", l1_levels, "\n\n")

# Display the number of observations per L1 group
table(data$L1)
```

# Collinearity and Outlier Detection

Before fitting our models, we'll check for multicollinearity among bioclimatic variables within each L1 region and identify outliers based on standard statistical criteria.

```{r check-collinearity}
#| label: check-collinearity
#| fig-height: 10
#| fig-width: 12

# Function to check for collinearity within an L1 group
check_collinearity <- function(data, l1_value) {
  # Subset data for the specific L1 group
  subset_data <- data[data$L1 == l1_value, ]
  
  # Extract just the bioclimatic variables
  bio_data <- subset_data[, paste0("bio", 1:19)]
  
  # Calculate correlation matrix
  cor_matrix <- cor(bio_data, use = "pairwise.complete.obs")
  
  # Identify highly correlated pairs (|r| > 0.7)
  high_cor <- which(abs(cor_matrix) > 0.7 & abs(cor_matrix) < 1, arr.ind = TRUE)
  
  # Create a dataframe of highly correlated pairs
  if (nrow(high_cor) > 0) {
    # Sort to avoid duplicates
    high_cor <- high_cor[high_cor[,1] < high_cor[,2], ]
    
    # Create a dataframe
    cor_pairs <- data.frame(
      Variable1 = colnames(bio_data)[high_cor[,1]],
      Variable2 = colnames(bio_data)[high_cor[,2]],
      Correlation = sapply(1:nrow(high_cor), function(i) 
        cor_matrix[high_cor[i,1], high_cor[i,2]])
    )
    
    # Add full variable names
    cor_pairs$Variable1_Full <- sapply(cor_pairs$Variable1, function(var) bio_names[var])
    cor_pairs$Variable2_Full <- sapply(cor_pairs$Variable2, function(var) bio_names[var])
    
    # Sort by absolute correlation
    cor_pairs <- cor_pairs[order(abs(cor_pairs$Correlation), decreasing = TRUE), ]
    
    return(cor_pairs)
  } else {
    return(NULL)
  }
}

# Function to compute VIF for variables in a model
compute_vif <- function(data, l1_value) {
  # Subset data for the specific L1 group
  subset_data <- data[data$L1 == l1_value, ]
  
  # Extract just the bioclimatic variables
  bio_data <- subset_data[, paste0("bio", 1:19)]
  
  # Calculate VIF for each variable
  vif_results <- data.frame(
    Variable = character(),
    VIF = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (i in 1:ncol(bio_data)) {
    # Formula for regressing this variable against all others
    dependent_var <- colnames(bio_data)[i]
    independent_vars <- colnames(bio_data)[-i]
    
    formula_str <- paste(dependent_var, "~", paste(independent_vars, collapse = " + "))
    formula_obj <- as.formula(formula_str)
    
    # Fit model
    model <- lm(formula_obj, data = bio_data)
    
    # Calculate VIF = 1/(1-R²)
    r_squared <- summary(model)$r.squared
    vif <- 1/(1-r_squared)
    
    # Add to results
    vif_results <- rbind(vif_results, data.frame(
      Variable = dependent_var,
      VIF = vif,
      stringsAsFactors = FALSE
    ))
  }
  
  # Add full variable names
  vif_results$Variable_Full <- sapply(vif_results$Variable, function(var) bio_names[var])
  
  # Sort by VIF
  vif_results <- vif_results[order(vif_results$VIF, decreasing = TRUE), ]
  
  return(vif_results)
}

# Check collinearity for each L1 group
collinearity_summary <- list()

for (level in l1_levels) {
  cat("\nChecking collinearity for L1 =", level, "\n")
  
  # Get correlation pairs
  cor_pairs <- check_collinearity(data, level)
  
  # Get VIF values
  vif_values <- compute_vif(data, level)
  
  # Store results
  collinearity_summary[[level]] <- list(
    correlations = cor_pairs,
    vif = vif_values
  )
  
  # Report high correlations
  if (!is.null(cor_pairs) && nrow(cor_pairs) > 0) {
    cat("Found", nrow(cor_pairs), "highly correlated pairs (|r| > 0.7):\n")
    print(cor_pairs[, c("Variable1_Full", "Variable2_Full", "Correlation")])
  } else {
    cat("No highly correlated pairs found.\n")
  }
  
  # Report high VIF values
  high_vif <- vif_values[vif_values$VIF > 5, ]
  if (nrow(high_vif) > 0) {
    cat("\nVariables with high VIF (> 5) indicating multicollinearity:\n")
    print(high_vif[, c("Variable_Full", "VIF")])
  } else {
    cat("\nNo variables with concerning VIF values found.\n")
  }
  
  cat("\n------------------------------------------------------\n")
}
```

# Outlier Detection and Model Fitting

After checking for collinearity, we'll now identify outliers and fit our models.

```{r outlier-detection}
#| label: outlier-detection
#| fig-height: 10
#| fig-width: 12

# Function to identify outliers and fit models for each L1 group
run_model_by_l1 <- function(data, l1_value) {
  # Subset data for a specific L1 value
  subset_data <- data[data$L1 == l1_value, ]
  
  # Create formula with all bio variables
  formula <- as.formula("cwe ~ bio1 + bio2 + bio3 + bio4 + bio5 + bio6 + bio7 + bio8 + 
                        bio9 + bio10 + bio11 + bio12 + bio13 + bio14 + bio15 + 
                        bio16 + bio17 + bio18 + bio19")
  
  # First fit the initial model to identify outliers
  initial_model <- lm(formula, data = subset_data)
  
  # Calculate diagnostic measures
  stud_resid <- rstudent(initial_model)
  cooks_d <- cooks.distance(initial_model)
  leverage <- hatvalues(initial_model)
  
  # Set thresholds for outlier detection
  n <- nrow(subset_data)
  p <- length(coef(initial_model)) - 1
  
  # Identify outliers (observations exceeding any threshold)
  outliers <- which(abs(stud_resid) > 3 | 
                    cooks_d > 4/n | 
                    leverage > 2*(p+1)/n)
  
  # If outliers found, create diagnostic plots and remove them
  if (length(outliers) > 0) {
    # Display diagnostic plots with outliers highlighted
    par(mfrow = c(2, 2))
    plot(initial_model)
    points(fitted(initial_model)[outliers], 
           residuals(initial_model)[outliers],
           col = "red", pch = 19, cex = 1.5)
    
    # Report outliers found
    cat("\nDetected", length(outliers), "outliers in", l1_value, "group\n")
    
    # Remove outliers
    clean_data <- subset_data[-outliers, ]
    cat("Removed outliers. Proceeding with", nrow(clean_data), "observations\n")
  } else {
    cat("\nNo outliers detected in", l1_value, "group\n")
    clean_data <- subset_data
  }
  
  # Fit the full model with clean data
  full_model <- lm(formula, data = clean_data)
  
  # Perform stepwise selection
  final_model <- step(full_model, direction = "both", trace = FALSE)
  
  # Return both the final model and number of outliers removed
  return(list(
    model = final_model,
    n_outliers = length(outliers),
    n_original = nrow(subset_data),
    n_final = nrow(clean_data)
  ))
}
```

# Running Models by L1 Group

Now we'll fit models for each L1 group, accounting for both collinearity and outliers. We'll use stepwise regression, but exclude highly collinear variables identified earlier.

```{r run-models}
#| label: run-models

# Modified function to run models that accounts for collinearity
run_model_by_l1_with_collinearity <- function(data, l1_value, collinearity_info) {
  # Subset data for a specific L1 value
  subset_data <- data[data$L1 == l1_value, ]
  
  # Check VIF information to identify variables to exclude
  vif_values <- collinearity_info[[l1_value]]$vif
  high_vif_vars <- vif_values$Variable[vif_values$VIF > 10]  # VIF > 10 indicates serious multicollinearity
  
  if (length(high_vif_vars) > 0) {
    cat("Excluding variables with high VIF:", paste(high_vif_vars, collapse=", "), "\n")
  }
  
  # Create formula excluding high VIF variables
  bio_vars <- paste0("bio", 1:19)
  bio_vars <- bio_vars[!(bio_vars %in% high_vif_vars)]
  
  formula_str <- paste("cwe ~", paste(bio_vars, collapse = " + "))
  formula <- as.formula(formula_str)
  
  # First fit the initial model to identify outliers
  initial_model <- lm(formula, data = subset_data)
  
  # Calculate diagnostic measures
  stud_resid <- rstudent(initial_model)
  cooks_d <- cooks.distance(initial_model)
  leverage <- hatvalues(initial_model)
  
  # Set thresholds for outlier detection
  n <- nrow(subset_data)
  p <- length(coef(initial_model)) - 1
  
  # Identify outliers (observations exceeding any threshold)
  outliers <- which(abs(stud_resid) > 3 | 
                    cooks_d > 4/n | 
                    leverage > 2*(p+1)/n)
  
  # If outliers found, create diagnostic plots and remove them
  if (length(outliers) > 0) {
    # Display diagnostic plots with outliers highlighted
    par(mfrow = c(2, 2))
    plot(initial_model)
    points(fitted(initial_model)[outliers], 
           residuals(initial_model)[outliers],
           col = "red", pch = 19, cex = 1.5)
    
    # Report outliers found
    cat("\nDetected", length(outliers), "outliers in", l1_value, "group\n")
    
    # Remove outliers
    clean_data <- subset_data[-outliers, ]
    cat("Removed outliers. Proceeding with", nrow(clean_data), "observations\n")
  } else {
    cat("\nNo outliers detected in", l1_value, "group\n")
    clean_data <- subset_data
  }
  
  # Fit the full model with clean data
  full_model <- lm(formula, data = clean_data)
  
  # Perform stepwise selection
  final_model <- step(full_model, direction = "both", trace = FALSE)
  
  # Return both the final model and number of outliers removed
  return(list(
    model = final_model,
    n_outliers = length(outliers),
    n_original = nrow(subset_data),
    n_final = nrow(clean_data),
    excluded_vars = high_vif_vars
  ))
}

# Create storage for models and outlier summary
l1_models <- list()
outlier_summary <- data.frame(
  L1_Level = character(),
  Total_Observations = numeric(),
  Outliers_Removed = numeric(),
  Final_Observations = numeric(),
  Excluded_Variables = character(),
  stringsAsFactors = FALSE
)

# Loop through each L1 level
for (level in l1_levels) {
  model_name <- paste("L1_", level, sep = "")
  cat("Running model for", model_name, "\n")
  
  # Try to fit the model, handling any errors
  tryCatch({
    # Run the model with collinearity checking
    result <- run_model_by_l1_with_collinearity(data, level, collinearity_summary)
    
    # Store the model
    l1_models[[model_name]] <- result$model
    
    # Format excluded variables for summary
    excluded_vars_str <- if(length(result$excluded_vars) > 0) {
      paste(sapply(result$excluded_vars, function(var) bio_names[var]), collapse = ", ")
    } else {
      "None"
    }
    
    # Add to outlier summary
    outlier_summary <- rbind(outlier_summary, data.frame(
      L1_Level = level,
      Total_Observations = result$n_original,
      Outliers_Removed = result$n_outliers,
      Final_Observations = result$n_final,
      Excluded_Variables = excluded_vars_str,
      stringsAsFactors = FALSE
    ))
    
    # Print model summary
    cat("\nModel summary for L1 =", level, ":\n")
    print(summary(result$model))
    cat("\n------------------------------------------------------\n\n")
  }, 
  error = function(e) {
    cat("Error in model for L1 =", level, ":", e$message, "\n\n")
  })
}

# Print outlier removal summary
cat("\nSummary of Outlier Removal:\n")
kable(outlier_summary, 
      caption = "Outlier Removal Summary by L1 Group",
      digits = 0)
```

# Model Comparison

```{r compare-models}
#| label: compare-models

# Create an empty dataframe for model comparison
model_comparison <- data.frame(
  L1_Level = character(),
  R_squared = numeric(),
  Adj_R_squared = numeric(),
  F_statistic = numeric(),
  p_value = numeric(),
  Significant_Predictors = character(),
  stringsAsFactors = FALSE
)

# Extract key statistics from each model
for (i in seq_along(l1_models)) {
  # Get current model and name
  model <- l1_models[[i]]
  model_name <- names(l1_models)[i]
  l1_level <- sub("L1_", "", model_name)
  
  # Extract model statistics
  model_summary <- summary(model)
  
  # Identify significant predictors (p < 0.05)
  coef_table <- coef(model_summary)
  sig_predictors <- rownames(coef_table)[coef_table[, "Pr(>|t|)"] < 0.05 & 
                                         rownames(coef_table) != "(Intercept)"]
  
  # Replace bio variable codes with full names
  sig_predictors_full <- sapply(sig_predictors, function(var) {
    if (var %in% names(bio_names)) {
      return(bio_names[var])
    } else {
      return(var)  # Keep as is if not a bio variable
    }
  })
  
  sig_predictors_str <- paste(sig_predictors_full, collapse = ", ")
  
  # Calculate p-value from F-statistic
  p_val <- pf(model_summary$fstatistic[1], 
              model_summary$fstatistic[2], 
              model_summary$fstatistic[3], 
              lower.tail = FALSE)
  
  # Add to comparison table
  model_comparison <- rbind(model_comparison, data.frame(
    L1_Level = l1_level,
    R_squared = model_summary$r.squared,
    Adj_R_squared = model_summary$adj.r.squared,
    F_statistic = model_summary$fstatistic[1],
    p_value = p_val,
    Significant_Predictors = sig_predictors_str,
    stringsAsFactors = FALSE
  ))
}

# Print comparison table
kable(model_comparison, 
      caption = "Model Comparison Across L1 Groups",
      digits = 4)
```

# Coefficient Comparison

```{r coefficient-plot}
#| label: coefficient-plot
#| fig-height: 10
#| fig-width: 14
#| fig-cap: "Comparison of bioclimatic variable coefficients across L1 groups"

# Create a data frame to store all coefficients
all_coefficients <- data.frame()

# Extract coefficients from each model
for (i in seq_along(l1_models)) {
  model <- l1_models[[i]]
  model_name <- names(l1_models)[i]
  l1_level <- sub("L1_", "", model_name)
  
  # Get coefficients and their p-values
  coef_data <- summary(model)$coefficients
  
  # Convert to data frame
  coef_df <- as.data.frame(coef_data)
  coef_df$Variable <- rownames(coef_data)
  coef_df$L1_Group <- l1_level
  
  # Rename columns for clarity
  names(coef_df)[1:4] <- c("Estimate", "Std_Error", "t_value", "p_value")
  
  # Add to the combined data frame
  all_coefficients <- rbind(all_coefficients, coef_df)
}

# Remove intercept for plotting
plot_coefficients <- subset(all_coefficients, Variable != "(Intercept)")

# Extract just bio variables (removing any other predictors if they exist)
bio_vars <- plot_coefficients[grep("^bio[0-9]+$", plot_coefficients$Variable), ]

# Add full variable names
bio_vars$FullName <- sapply(bio_vars$Variable, function(var) bio_names[var])

# Create the coefficient plot
ggplot(bio_vars, aes(x = FullName, y = Estimate, fill = L1_Group)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Estimate - 1.96 * Std_Error, 
                    ymax = Estimate + 1.96 * Std_Error),
                width = 0.2, position = position_dodge(0.9)) +
  theme_bw() +
  labs(title = "Coefficient Estimates for Bioclimatic Variables by L1 Group",
       x = "Bioclimatic Variable",
       y = "Coefficient Estimate (with 95% CI)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Interpretation and Conclusions

From the analysis above, we can draw the following conclusions:

1.  **Model Fit**: Some L1 groups show better overall model fit than others, as indicated by the R² values.

2.  **Significant Predictors**: Different bioclimatic variables are significant across different L1 groups, suggesting that the relationship between climate and `cwe` varies depending on the L1 category.

3.  **Coefficient Differences**: The magnitude and direction of effects vary across L1 groups, showing that the same bioclimatic factor can have different impacts depending on the L1 group.

4.  **Outlier Impact**: By removing outliers, we've improved the reliability of our models and can have more confidence in the relationships identified.

## Key Takeaways

-   The relationship between bioclimatic variables and `cwe` is not uniform across L1 groups
-   Some L1 groups show stronger climate-`cwe` relationships than others
-   Specific bioclimatic variables may be more important for certain L1 groups

## Next Steps

1.  Consider interaction terms to formally test if L1 moderates the relationship between specific bioclimatic variables and `cwe`
2.  Validate the models with independent data if available
3.  Investigate why certain bioclimatic variables are more important for specific L1 groups

# Appendix: Variable Descriptions

For reference, here are descriptions of the bioclimatic variables used in this analysis:

-   **Annual Mean Temperature**: Mean annual air temperature (°C)
-   **Mean Diurnal Range**: Mean of monthly (max temp - min temp) (°C)
-   **Isothermality**: (Mean Diurnal Range / Temperature Annual Range) × 100
-   **Temperature Seasonality**: Standard deviation of temperatures × 100
-   **Max Temperature of Warmest Month**: Maximum temperature of the warmest month (°C)
-   **Min Temperature of Coldest Month**: Minimum temperature of the coldest month (°C)
-   **Temperature Annual Range**: Maximum temp - minimum temp (°C)
-   **Mean Temperature of Wettest Quarter**: Mean temperature during the wettest quarter (°C)
-   **Mean Temperature of Driest Quarter**: Mean temperature during the driest quarter (°C)
-   **Mean Temperature of Warmest Quarter**: Mean temperature during the warmest quarter (°C)
-   **Mean Temperature of Coldest Quarter**: Mean temperature during the coldest quarter (°C)
-   **Annual Precipitation**: Sum of monthly precipitation values (mm)
-   **Precipitation of Wettest Month**: Precipitation of the wettest month (mm)
-   **Precipitation of Driest Month**: Precipitation of the driest month (mm)
-   **Precipitation Seasonality**: Coefficient of variation in precipitation
-   **Precipitation of Wettest Quarter**: Precipitation during the wettest quarter (mm)
-   **Precipitation of Driest Quarter**: Precipitation during the driest quarter (mm)
-   **Precipitation of Warmest Quarter**: Precipitation during the warmest quarter (mm)
-   **Precipitation of Coldest Quarter**: Precipitation during the coldest quarter (mm)

And `cwe` refers to: \[Include definition of your response variable here\]
